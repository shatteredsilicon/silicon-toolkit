#!/usr/bin/env perl

# This is st-sideload-relay, a program to sideload relay logs on a MySQL slave.
#
# Copyright (C) 2023  Shattered Silicon Ltd.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

use strict;
use warnings FATAL => 'all';

our $VERSION = '1.0.0';

# ############################################################################
# Option package
# ############################################################################
package Option;

use strict;
use Getopt::Long qw(:config no_ignore_case auto_version);
use English qw(-no_match_vars);
use Pod::Usage;
use Data::Dumper;
use Config::IniFiles;
use constant STDEBUG => $ENV{STDEBUG} || 0;

sub new {
  my ( $class, $opt_str ) = @_;

  my $initial_prefetch = 2 * 1024 * 1024 * 1024; # default 2G
  my $io_thread_threshold = 1024 * 1024 * 1024; # default 1G

  my %options = (
    "initial-prefetch=s" => sub { my ($name, $value) = @_; my $val = parse_size_arg($name, $value); if (defined $val) { $initial_prefetch = $val; } else { pod2usage; } },
    "io-thread-threshold=s" => sub { my ($name, $value) = @_; my $val = parse_size_arg($name, $value); if (defined $val) { $io_thread_threshold = $val; } else { pod2usage; } },
    "channel-name|C=s" => \(my $channel_name = ''),
    "user|u=s" => \my $user,
    "password|p=s" => \my $password,
    "host|h=s" => \my $host,
    "socket|S=s" => \my $socket,
    "port|P=i" => \(my $port = 3306),
    "tmp-dir=s" => \(my $tmp_dir = '/tmp'),
  );
  GetOptions(
    %options
  ) or pod2usage(-verbose => 1);

  my $self = {
    args => {
      'initial-prefetch' => $initial_prefetch,
      'io-thread-threshold' => $io_thread_threshold,
      'channel-name' => $channel_name,
      'user' => $user,
      'password' => $password,
      'host' => $host,
      'socket' => $socket,
      'port' => $port,
      'tmp-dir' => $tmp_dir,
    },
  };

  if (defined $opt_str) {
    foreach my $opt ( split(qr/(?<!\\),/, $opt_str) ) {
      $opt =~ s/\\,/,/g;
      if ( my ($opt_key, $opt_val) = $opt =~  m/^(.)=(.*)$/ ) {
        foreach my $arg_key ( keys %options ) {
          my @name_str = split(/(=|\+|\!|:)/, $arg_key);
          my @names = split(/\|/, $name_str[0]);
          my $primary_name = $names[0];

          foreach my $name (@names[1..$#names]) {
            if ($name eq $opt_key) {
              $self->{args}->{$primary_name} = $opt_val;
              last;
            }
          }
        }
      }
    }
  }

  STDEBUG && print "args: " . Dumper($self->{args});

  return bless $self, $class;
}

sub get_option {
  my ( $self, $key ) = @_;

  return $self->{args}->{$key};
}

sub parse_dsn {
  my ( $self ) = @_;

  my @conf_files = (
    "/etc/my.cnf",
    "/etc/mysql/my.cnf",
    "/usr/etc/my.cnf",
    "$ENV{HOME}/.my.cnf",
  );

  # get credentials from files
  foreach my $conf_file (@conf_files) {
    STDEBUG && print $conf_file . "\n";
    if (! -e "$conf_file") {
      next;
    }

    if (tie my %ini, 'Config::IniFiles', ( -file => "$conf_file" )) {
      if (!defined $ini{client}) {
        next;
      }

      if (defined $ini{client}{user} && !defined $self->{args}->{user}) {
        $self->{args}->{user} = $ini{client}{user};
      }

      if (defined $ini{client}{password} && !defined $self->{args}->{password}) {
        $self->{args}->{password} = $ini{client}{password};
      }

      if (defined $ini{client}{host} && !defined $self->{args}->{host}) {
        $self->{args}->{host} = $ini{client}{host};
      }

      if (defined $ini{client}{port} && !defined $self->{args}->{port}) {
        $self->{args}->{port} = $ini{client}{port};
      }

      if (defined $ini{client}{socket} && !defined $self->{args}->{socket}) {
        $self->{args}->{socket} = $ini{client}{socket};
      }
    }
  }

  # user still not defined, set user to
  # current login user
  if (!defined $self->{args}->{user}) {
    $self->{args}->{user} = $ENV{LOGNAME} || getpwuid($<) || $ENV{USER} . '@localhost';
  }

  if (defined $self->{args}->{host} || defined $self->{args}->{socket}) {
    return;
  }

  # read default socket path from output of
  # 'mysqlbinlog --print-defaults'
  open FH, "mysqlbinlog --print-defaults |";
	my @lines = <FH>;
	close FH;

  foreach my $line (@lines) {
    if (my ( $path ) = $line =~ m/--socket=(\S+)/) {
      $self->{args}->{socket} = "$path";
      last;
    }
  }

  # can't get default socket patch, use
  # default host 'localhost'
  if (!defined $self->{args}->{socket}) {
    $self->{args}->{host} = 'localhost';
  }

  STDEBUG && print "args: " . Dumper($self->{args});
}

sub parse_size_arg {
  my ($name, $value) = @_;

  my %factor_for = (
    K => 1_024,
    M => 1_048_576,
    G => 1_073_741_824,
    T => 1_099_511_627_776,
  );

  my ($pre, $num, $factor) = $value =~ m/^([+-])?(\d+)([KMGT])?B?$/;
  if ( defined $num ) {
    if ( $factor ) {
        $num *= $factor_for{$factor};
    }
    STDEBUG && print $name . ": " . $num . "\n";
    return $num * 1;
  }

  return undef;
}

# ############################################################################
# DB package
# ############################################################################
package DB;

use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);
use Data::Dumper;
use constant STDEBUG => $ENV{STDEBUG} || 0;

my @DB_TRUES = (1,"true","True","TRUE","yes","Yes","YES","on","On","ON");

eval {
   require DBI;
};
my $have_dbi = $EVAL_ERROR ? 0 : 1;

sub new {
  my ( $class, %args ) = @_;
  $args{attrs} ||= {};

  my $defaults = {
    AutoCommit         => 0,
    RaiseError         => 1,
    PrintError         => 0,
    ShowErrorStatement => 1,
    mysql_enable_utf8 => (defined $args{dsn} && $args{dsn} =~ m/charset=utf8/i ? 1 : 0),
  };
  @{$defaults}{ keys %{$args{attrs}} } = values %{$args{attrs}};

  if ( !$have_dbi ) {
    die "Cannot connect to MySQL because the Perl DBI module is not "
        . "installed or not found.  Run 'perl -MDBI' to see the directories "
        . "that Perl searches for DBI.  If DBI is not installed, try:\n"
        . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
        . "  RHEL/CentOS    yum install perl-DBI\n"
        . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
  }

  my $dsn = get_dbi_dsn($args{host}, $args{port}, $args{socket});
  STDEBUG && print 'dsn: ' . $dsn . "\n";

  my $dbh;
  my $tries = 2;
  while ( !$dbh && $tries-- ) {
    eval {
        $dbh = DBI->connect($dsn, $args{user}, $args{password}, $defaults);
    };
    if ( !$dbh && $EVAL_ERROR ) {
        STDEBUG && print $EVAL_ERROR;
        if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
          STDEBUG && print 'Going to try again without utf8 support';
          delete $defaults->{mysql_enable_utf8};
        }
        elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
          die "Cannot connect to MySQL because the Perl DBD::mysql module is "
              . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
              . "the directories that Perl searches for DBD::mysql.  If "
              . "DBD::mysql is not installed, try:\n"
              . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
              . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
              . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
        }
        if ( !$tries ) {
          die $EVAL_ERROR;
        }
    }
  }

  STDEBUG && print 'DBH info: ',
    $dbh,
    Dumper($dbh->selectrow_hashref(
        'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
    'Connection info:',      $dbh->{mysql_hostinfo},
    'Character set info:',   Dumper($dbh->selectall_arrayref(
                    'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
    '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
    '$DBI::VERSION:',        $DBI::VERSION, "\n";

  my $self = {
    dbh => $dbh,
  };

  return bless $self, $class;
}

sub get_dbi_dsn {
  my ( $host, $port, $socket ) = @_;

  if (!$host && !$socket) {
    return undef;
  }

  my $dsn = "DBI:mysql:;port=$port";
  if ($socket) {
    $dsn = "${dsn};socket=$socket;";
  } else {
    $dsn = "${dsn};host=$host;";
  }

  return $dsn;
}

sub disconnect {
  my ( $self ) = @_;
  $self->{dbh}->disconnect();
}

sub is_true {
  my ( $self, $value ) = @_;
  return grep $_ eq $value, @DB_TRUES;
}

# ############################################################################
# st_sideload_relay program.
# ############################################################################
package st_sideload_relay;

use warnings FATAL => 'all';
use English qw(-no_match_vars);
use Data::Dumper;
use File::Basename;
use File::Spec::Functions 'catfile';
use constant STDEBUG => $ENV{STDEBUG} || 0;

sub main {
  my @ARGV = @_;

  my $o = new Option(shift @ARGV);
  $o->parse_dsn();

  my $db = new DB(
    host => $o->get_option('host'),
    port => $o->get_option('port'),
    socket => $o->get_option('socket'),
    user => $o->get_option('user'),
    password => $o->get_option('password'),
  );

  my $channel_name = $o->get_option('channel-name');
  my $initial_prefetch = $o->get_option('initial-prefetch');
  my $io_thread_threshold = $o->get_option('io-thread-threshold');
  my $tmp_dir = $o->get_option('tmp-dir');

  # get master info from mysql.slave_master_info
  my $master_info;
  eval { $master_info = $db->{dbh}->selectrow_hashref('SELECT * FROM mysql.slave_master_info WHERE Channel_name = \'' . $channel_name . '\'') };
  if ($EVAL_ERROR) {
    $db->disconnect() if $db;
    die "Failed to get master info from mysql.slave_master_info for channel '${channel_name}': ${EVAL_ERROR}";
  }

  if (!$master_info) {
    $db->disconnect() if $db;
    die "No master info found for channel '" . $channel_name . "'";
  }

  STDEBUG && print Dumper($master_info);

  # get initial slave status
  my $init_slave_status;
  eval { $init_slave_status = $db->{dbh}->selectrow_hashref('SHOW SLAVE STATUS FOR CHANNEL \'' . $channel_name . '\'') };
  if ($EVAL_ERROR) {
    $db->disconnect() if $db;
    die "Failed to get slave status info for channel '${channel_name}': ${EVAL_ERROR}";
  }

  STDEBUG && print Dumper($init_slave_status);

  # stop io_thread
  eval { $db->{dbh}->do("STOP SLAVE io_thread FOR CHANNEL '${channel_name}'") };
  if ($EVAL_ERROR) {
    $db->disconnect() if $db;
    die "Can't stop io_thread for channel '$channel_name': ${EVAL_ERROR}";
  }

  my $initial_run = 1;

  EVENT:
  while (1) {
    sleep 1;

    # get slave status
    my $slave_status;
    eval { $slave_status = $db->{dbh}->selectrow_hashref("SHOW SLAVE STATUS FOR CHANNEL '${channel_name}'") };
    if ($EVAL_ERROR) {
      warn "Failed to get slave status info for channel '${channel_name}': ${EVAL_ERROR}";
      next EVENT;
    }

    # if there is an IO/SQL error, we don't want to continue
    # in this situation
    if ($slave_status->{Last_SQL_Error} || $slave_status->{Last_IO_Error}) {
      warn "Exiting because there is an IO/SQL error, Last_SQL_Error: $slave_status->{Last_SQL_Error}, Last_IO_Error: $slave_status->{Last_IO_Error}";
      last EVENT;
    }

    # get master binlog list 
    open ML, "mysql -h $master_info->{Host} -u $master_info->{User_name} --password=$master_info->{User_password} -N -B -e \"SHOW MASTER LOGS\" 2>/dev/null |";
    my @master_logs_output = <ML>;
    close ML;

    # walk through binlog list, get those we need to fetch
    my $master_log_pos = $slave_status->{Read_Master_Log_Pos};
    my @master_log_files = ();
    my $exec_master_log_found = 0;
    my $exec_read_pos_offset = 0;
    foreach my $i (0 .. $#master_logs_output) {
      chomp $master_logs_output[$i];
      STDEBUG && print $master_logs_output[$i], "\n";

      my @master_logs_fields = split(' ', $master_logs_output[$i]); # in order 'Log_name', 'File_size', 'Encrypted'

      if (!$exec_master_log_found && $slave_status->{Relay_Master_Log_File} eq $master_logs_fields[0]) {
        $exec_master_log_found = 1;
      }

      if ($exec_master_log_found) {
        if ($slave_status->{Relay_Master_Log_File} eq $slave_status->{Master_Log_File}) {
          $exec_read_pos_offset = $slave_status->{Read_Master_Log_Pos} - $slave_status->{Exec_Master_Log_Pos};
        } elsif ($master_logs_fields[0] eq $slave_status->{Master_Log_File}) {
          $exec_read_pos_offset += $slave_status->{Read_Master_Log_Pos};
        } elsif ($slave_status->{Relay_Master_Log_File} eq $master_logs_fields[0]) {
          $exec_read_pos_offset += $master_logs_fields[1] - $slave_status->{Exec_Master_Log_Pos};
        } else {
          $exec_read_pos_offset += $master_logs_fields[1];
        }
      }

      if ($master_logs_fields[0] ne $slave_status->{Master_Log_File}) {
        next;
      }

      if ($master_logs_fields[1] eq $master_log_pos && $i eq $#master_logs_output) {
        last EVENT;
      }

      my @rest_lines = ();
      if ($master_logs_fields[1] eq $master_log_pos) {
        @rest_lines = @master_logs_output[ $i+1 .. $#master_logs_output ];
        $master_log_pos = 0;
      } else {
        @rest_lines = @master_logs_output[ $i .. $#master_logs_output ];
      }

      @master_log_files = map {
        my $line = $_;
        chomp $line;
        my @fields = split(' ', $line);
        $fields[0];
      } @rest_lines;

      last;
    }

    if ((scalar @master_log_files) eq 0) {
      last EVENT;
    }

    if ($io_thread_threshold > 0 && $exec_read_pos_offset > $io_thread_threshold) {
      STDEBUG && print "exiting because it reaches io-thread-threshold, io-thread-threshold: ${io_thread_threshold}, distance to current end of relay log: ${exec_read_pos_offset}\n";
      last EVENT;
    }

    STDEBUG && print "fetching relay_log_basename for channel '${channel_name}'\n";

    # get relay log basename, so we know where the
    # relay index file is
    my $relay_log_basename;
    eval { $relay_log_basename = $db->{dbh}->selectrow_arrayref('SELECT @@relay_log_basename')->[0] };
    if ($EVAL_ERROR) {
      warn "Can't get relay log basename location for channel '${channel_name}': ${EVAL_ERROR}";
      next EVENT;
    }

    my $relay_log_index;
    if ($channel_name eq "") {
      $relay_log_index = $relay_log_basename . '.index';
    } else {
      $relay_log_index = $relay_log_basename . "-${channel_name}" . ".index";
    }

    STDEBUG && print "parsed relay log index file '$relay_log_index' for channel '${channel_name}'\n";

    my $relay_log_space_limit;
    eval { $relay_log_space_limit = $db->{dbh}->selectrow_arrayref('SELECT @@relay_log_space_limit')->[0] };
    if ($EVAL_ERROR) {
      warn "Can't get relay log space limit for channel '${channel_name}': ${EVAL_ERROR}";
      next EVENT;
    }

    my $relay_log_space_size = 0;
    if ($relay_log_space_limit gt 0) {
      my $relay_log_fh;
      eval { open $relay_log_fh, "<", $relay_log_index };
      if ($EVAL_ERROR) {
        warn "Can't open relay log index file '${relay_log_index}': ${EVAL_ERROR}";
        next EVENT;
      }

      my @relay_log_index_lines = <$relay_log_fh>;
      close $relay_log_fh;

      foreach my $line (@relay_log_index_lines) {
        chomp $line;
        my $relay_log = catfile(dirname($relay_log_basename), basename($line));
        my $relay_log_size;
        eval { $relay_log_size = `wc -c < ${relay_log}` };
        if ($EVAL_ERROR) {
          warn "Failed to get file size of relay log '${relay_log}' for channel '${channel_name}': ${EVAL_ERROR}";
          next EVENT;
        }
        $relay_log_space_size += $relay_log_size;
      }

      if ($relay_log_space_size gt $relay_log_space_limit) {
        STDEBUG && print "exiting because it exceeds relay log space limit\n";
        last EVENT;
      }
    }

    # walk through waiting binlog list,
    # fetch them with mysqlbinlog
    my $master_pos_offset = 0;
    my @fetched_binlog_files = ();
    my $latest_master_log_file;
    my $latest_master_log_pos;
    foreach my $i ( 0 .. $#master_log_files ) {
      my $master_log_file = $master_log_files[$i];
      my $pos = $i eq 0 ? $master_log_pos : 0;

      STDEBUG && print "fetching binlog '$master_log_file' at position '$pos' from server -h $master_info->{Host} -u $master_info->{User_name} --password=$master_info->{User_password}\n";

      my $result_file_prefix = catfile($tmp_dir, "/");
      my $mysqlbinlog_output;
      eval { $mysqlbinlog_output = `mysqlbinlog -h $master_info->{Host} -u $master_info->{User_name} --password=$master_info->{User_password} --read-from-remote-server --raw --result-file=/tmp/ --start-position=$pos $master_log_file 2>&1` };
      if ($? ne 0 || $EVAL_ERROR) {
        warn "Failed to fetch binlog from master for channel '${channel_name}': ${mysqlbinlog_output}";
        next EVENT;
      }

      my $fetched_binlog = catfile($tmp_dir, "$master_log_file");
      my $fetched_binlog_size;
      eval { $fetched_binlog_size = `wc -c < ${fetched_binlog}` };
      if ($EVAL_ERROR) {
        warn "Failed to get file size of fetched binlog '${fetched_binlog}' for channel '${channel_name}': ${EVAL_ERROR}";
        next EVENT;
      }

      if ($relay_log_space_limit gt 0 && ($relay_log_space_size + $fetched_binlog_size) > $relay_log_space_limit) {
        # it will exceed relay log space limit if we take this
        # binlog file, we stop here
        last;
      }

      my $trimed_binlog_size = $pos eq 0 ? $fetched_binlog_size : $fetched_binlog_size - 126;
      $master_pos_offset += $trimed_binlog_size;
      push(@fetched_binlog_files, $fetched_binlog);
      $latest_master_log_file = $master_log_file;
      $latest_master_log_pos = $i eq 0 ? $master_log_pos + $trimed_binlog_size : $trimed_binlog_size;

      if ( !$initial_run || $master_pos_offset > $initial_prefetch ) {
        STDEBUG && print "exiting fetching binlog because it's not an initial run or it reaches size of initial prefetch, initial_run: $initial_run, master_pos_offset: $master_pos_offset, initial_prefetch: $initial_prefetch\n";
        last;
      }
    }

    if ((scalar @fetched_binlog_files) eq 0) {
      STDEBUG && print "exiting because it will exceeds relay log space limit if continue\n";
      last EVENT;
    }

    STDEBUG && print "stopping sql_thread for channel '${channel_name}'\n";

    eval { $db->{dbh}->do("STOP SLAVE sql_thread FOR CHANNEL '${channel_name}'") };
    if ($EVAL_ERROR) {
      warn "Can't stop sql_thread for channel '$channel_name': ${EVAL_ERROR}";
      next EVENT;
    }

    STDEBUG && print "flushing relay logs for channel '${channel_name}'\n";

    eval { $db->{dbh}->do("FLUSH RELAY LOGS FOR CHANNEL '${channel_name}'") };
    if ($EVAL_ERROR) {
      warn "Can't flush relay logs for channel '$channel_name': ${EVAL_ERROR}";
      next EVENT;
    }

    foreach my $i ( 0 .. $#fetched_binlog_files ) {
      eval { $db->{dbh}->do("FLUSH RELAY LOGS FOR CHANNEL '${channel_name}'") };
      if ($EVAL_ERROR) {
        warn "Can't flush relay logs for channel '$channel_name': ${EVAL_ERROR}";
        next EVENT;
      }
    }

    my $relay_log_fh;
    eval { open $relay_log_fh, "<", $relay_log_index };
    if ($EVAL_ERROR) {
      warn "Can't open relay log index file '${relay_log_index}': ${EVAL_ERROR}";
      next EVENT;
    }

    my @relay_log_index_lines = <$relay_log_fh>;
    close $relay_log_fh;

    # overwrite those flused relay log files with
    # fetched binlog files
    foreach my $i ( 0 .. $#fetched_binlog_files ) {
      my $fetched_binlog = $fetched_binlog_files[$i];
      my $relay_log = catfile(dirname($relay_log_basename), basename($relay_log_index_lines[-2-$#fetched_binlog_files+$i]));
      my $overwrite_relay_output = `cp ${fetched_binlog} ${relay_log}`;
      if ($? ne 0) {
        warn "Failed to overwrite latest relay log ${relay_log} with fetched binlog ${fetched_binlog} for channel '${channel_name}': ${overwrite_relay_output}";
        next EVENT;
      }
    }

    eval { $slave_status = $db->{dbh}->selectrow_hashref("SHOW SLAVE STATUS FOR CHANNEL '${channel_name}'") };
    if ($EVAL_ERROR) {
      warn "Failed to get slave status info for channel '${channel_name}': ${EVAL_ERROR}";
      next EVENT;
    }

    STDEBUG && print "changing master to RELAY_LOG_FILE='$slave_status->{Relay_Log_File}', RELAY_LOG_POS=$slave_status->{Relay_Log_Pos}, MASTER_LOG_FILE='${latest_master_log_file}', MASTER_LOG_POS=${latest_master_log_pos} for channel '${channel_name}'\n";

    eval { $db->{dbh}->do("CHANGE MASTER TO RELAY_LOG_FILE='$slave_status->{Relay_Log_File}', RELAY_LOG_POS=$slave_status->{Relay_Log_Pos}, MASTER_LOG_FILE='${latest_master_log_file}', MASTER_LOG_POS=${latest_master_log_pos} FOR CHANNEL '${channel_name}'") };
    if ($EVAL_ERROR) {
      warn "Can't update relay logs and master logs pos for channel '$channel_name': ${EVAL_ERROR}";
      next EVENT;
    }

    $initial_run = 0;

    # remove those fetched temporary binlog files
    foreach my $fetched_binlog ( @fetched_binlog_files ) {
      my $remove_fetched_binlog_output;
      eval { $remove_fetched_binlog_output = `rm -f ${fetched_binlog} 2>&1` };
      if ($EVAL_ERROR) {
        warn "Failed to delete fetched binlog file '${fetched_binlog}' for channel '$channel_name': ${EVAL_ERROR}";
      }
    }

    STDEBUG && print "starting sql_thread for channel '${channel_name}'\n";

    eval { $db->{dbh}->do("START SLAVE sql_thread FOR CHANNEL '${channel_name}'") };
    if ($EVAL_ERROR) {
      warn "Can't start sql_thread for channel '$channel_name': ${EVAL_ERROR}";
      next EVENT;
    }
  }

  # start io_thread if it was running
  if ($db->is_true($init_slave_status->{Slave_IO_Running})) {
    eval { $db->{dbh}->do("START SLAVE io_thread FOR CHANNEL '$channel_name'") };
    if ($EVAL_ERROR) {
      warn "Can't start io_thread for channel '$channel_name': ${EVAL_ERROR}";
    }
  }

  $db->disconnect() if $db;
  return 0;
}

# ############################################################################
# Run the program.
# ############################################################################
if ( !caller ) { exit main(@ARGV); }

1; # Because this is a module as well as a script.

# ############################################################################
# Documentation.
# ############################################################################

__END__

=head1 NAME

st-sideload-relay - a program to sideload relay logs on a MySQL slave

=head1 SYNOPSIS

Usage: st-sideload-relay [OPTION...] [DSN]

st-sideload-relay sideloads relay logs on a MySQL slave

Example:

  st-sideload-relay

  st-sideload-relay --channel-name=prod

  st-sideload-relay -u mysql -h master1

  st-sideload-relay u=mysql,p=mysql

Default credentials are read from the following files in the given order:
/etc/my.cnf /etc/mysql/my.cnf /usr/etc/my.cnf ~/.my.cnf

=head1 DESCRIPTION

st-sideload-relay fetches binlog from master/source and sideloads it while
stopping the io_thread.

=head1 RISK

This program takes over the work of replication I/O thread. DO NOT run:
START SLAVE;
or
START SLAVE io_tread;
while this program is running or YOU WILL CORRUPT YOUR REPLICATION STREAM AND YOUR DATA!

=head1 OPTIONS

=over 8

=item B<--initial-prefetch>

type: size; default: 2G

The size limit for fetching the initial binlog.

=item B<--io-thread-threshold>

type: size; default: 1G

Keep prefetching the next batch of binlog until Exec_Master_Log_Pos and Master_Log_File
are this amount of data away from the end of the available relay logs.

=item B<--channel-name>

short form: -c; type: string

The name of the replication channel.

=item B<--user>

short form: -u; type: string

User for login if not current user.

=item B<--password>

short form: -p; type: string

Password to use when connecting.

=item B<--host>

short form: -h; type: string

Server to connect to.

=item B<--socket>

short form: -S; type: string

The socket file to use for connection.

=item B<--port>

short form: -P; type: integer

Server listen port.

=item B<--tmp-dir>

Directory for storing temporary files.

=item B<--help>

Print a brief help message and exits.

=item B<--version>

Show version and exit.

=cut
